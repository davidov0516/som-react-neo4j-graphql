"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionReadOperation = void 0;
const create_node_from_entity_1 = require("../../utils/create-node-from-entity");
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const operations_1 = require("./operations");
const utils_1 = require("../../../../utils/utils");
const context_has_target_1 = require("../../utils/context-has-target");
const CypherAttributeField_1 = require("../fields/attribute-fields/CypherAttributeField");
const CypherPropertySort_1 = require("../sort/CypherPropertySort");
const wrap_subquery_in_calls_1 = require("../../utils/wrap-subquery-in-calls");
class ConnectionReadOperation extends operations_1.Operation {
    constructor({ relationship, directed, target, }) {
        super();
        this.nodeFields = [];
        this.edgeFields = []; // TODO: merge with attachedTo?
        this.filters = [];
        this.sortFields = [];
        this.authFilters = [];
        this.relationship = relationship;
        this.directed = directed;
        this.target = target;
    }
    setNodeFields(fields) {
        this.nodeFields = fields;
    }
    setFilters(filters) {
        this.filters = filters;
    }
    setEdgeFields(fields) {
        this.edgeFields = fields;
    }
    addAuthFilters(...filter) {
        this.authFilters.push(...filter);
    }
    getAuthFilterSubqueries(context) {
        return this.authFilters.flatMap((f) => f.getSubqueries(context));
    }
    getAuthFilterPredicate(context) {
        return (0, utils_1.filterTruthy)(this.authFilters.map((f) => f.getPredicate(context)));
    }
    addSort(sortElement) {
        this.sortFields.push(sortElement);
    }
    addPagination(pagination) {
        this.pagination = pagination;
    }
    getChildren() {
        const sortFields = this.sortFields.flatMap((s) => {
            return [...s.edge, ...s.node];
        });
        return (0, utils_1.filterTruthy)([
            ...this.nodeFields,
            ...this.edgeFields,
            ...this.filters,
            ...this.authFilters,
            this.pagination,
            ...sortFields,
        ]);
    }
    getSelectionClauses(context, node) {
        let matchClause = new cypher_builder_1.default.Match(node);
        let extraMatches = this.getChildren().flatMap((f) => {
            return f.getSelection(context);
        });
        if (extraMatches.length > 0) {
            extraMatches = [matchClause, ...extraMatches];
            matchClause = new cypher_builder_1.default.With("*");
        }
        return {
            preSelection: extraMatches,
            selectionClause: matchClause,
        };
    }
    transpileNested(context) {
        if (!context.target || !this.relationship)
            throw new Error();
        const node = (0, create_node_from_entity_1.createNodeFromEntity)(this.target, context.neo4jGraphQLContext);
        const relationship = new cypher_builder_1.default.Relationship({ type: this.relationship.type });
        const relDirection = this.relationship.getCypherDirection(this.directed);
        const pattern = new cypher_builder_1.default.Pattern(context.target)
            .withoutLabels()
            .related(relationship)
            .withDirection(relDirection)
            .to(node);
        const nestedContext = context.push({ target: node, relationship });
        const { preSelection, selectionClause: clause } = this.getSelectionClauses(nestedContext, pattern);
        const predicates = this.filters.map((f) => f.getPredicate(nestedContext));
        const authPredicate = this.getAuthFilterPredicate(nestedContext);
        const authFilterSubqueries = this.getAuthFilterSubqueries(nestedContext);
        const filters = cypher_builder_1.default.and(...predicates, ...authPredicate);
        const nodeProjectionSubqueries = (0, wrap_subquery_in_calls_1.wrapSubqueriesInCypherCalls)(nestedContext, this.nodeFields, [node]);
        const nodeProjectionMap = new cypher_builder_1.default.Map();
        this.nodeFields
            .map((f) => f.getProjectionField(node))
            .forEach((p) => {
            if (typeof p === "string") {
                nodeProjectionMap.set(p, node.property(p));
            }
            else {
                nodeProjectionMap.set(p);
            }
        });
        if (nodeProjectionMap.size === 0) {
            const targetNodeName = this.target.name;
            nodeProjectionMap.set({
                __resolveType: new cypher_builder_1.default.Literal(targetNodeName),
                __id: cypher_builder_1.default.id(node),
            });
        }
        const edgeVar = new cypher_builder_1.default.NamedVariable("edge");
        const edgesVar = new cypher_builder_1.default.NamedVariable("edges");
        const totalCount = new cypher_builder_1.default.NamedVariable("totalCount");
        const edgeProjectionMap = new cypher_builder_1.default.Map();
        this.edgeFields
            .map((f) => f.getProjectionField(relationship))
            .forEach((p) => {
            if (typeof p === "string") {
                edgeProjectionMap.set(p, relationship.property(p));
            }
            else {
                edgeProjectionMap.set(p);
            }
        });
        edgeProjectionMap.set("node", nodeProjectionMap);
        let withWhere;
        if (filters) {
            if (authFilterSubqueries.length > 0) {
                // This is to avoid unnecessary With *
                withWhere = new cypher_builder_1.default.With("*").where(filters);
            }
            else {
                clause.where(filters);
            }
        }
        let sortSubquery;
        if (this.pagination || this.sortFields.length > 0) {
            const paginationField = this.pagination && this.pagination.getPagination();
            sortSubquery = this.getPaginationSubquery(nestedContext, edgesVar, paginationField);
            sortSubquery.addColumns(totalCount);
        }
        let extraWithOrder;
        if (this.sortFields.length > 0) {
            const sortFields = this.getSortFields({ context: nestedContext, nodeVar: node, edgeVar: relationship });
            extraWithOrder = new cypher_builder_1.default.With(relationship, node).orderBy(...sortFields);
        }
        const projectionClauses = new cypher_builder_1.default.With([edgeProjectionMap, edgeVar])
            .with([cypher_builder_1.default.collect(edgeVar), edgesVar])
            .with(edgesVar, [cypher_builder_1.default.size(edgesVar), totalCount]);
        const returnClause = new cypher_builder_1.default.Return([
            new cypher_builder_1.default.Map({
                edges: edgesVar,
                totalCount: totalCount,
            }),
            context.returnVariable,
        ]);
        const subClause = cypher_builder_1.default.concat(...preSelection, clause, ...authFilterSubqueries, withWhere, extraWithOrder, ...nodeProjectionSubqueries, projectionClauses, sortSubquery, returnClause);
        return {
            clauses: [subClause],
            projectionExpr: context.returnVariable,
        };
    }
    transpile({ context }) {
        if (this.relationship) {
            return this.transpileNested(context);
        }
        if (!(0, context_has_target_1.hasTarget)(context))
            throw new Error("No parent node found!");
        const node = (0, create_node_from_entity_1.createNodeFromEntity)(this.target, context.neo4jGraphQLContext, this.nodeAlias);
        const { preSelection, selectionClause } = this.getSelectionClauses(context, node);
        const predicates = this.filters.map((f) => f.getPredicate(context));
        const authPredicate = this.getAuthFilterPredicate(context);
        const authFilterSubqueries = this.getAuthFilterSubqueries(context);
        const filters = cypher_builder_1.default.and(...predicates, ...authPredicate);
        const { prePaginationSubqueries, postPaginationSubqueries } = this.getPreAndPostSubqueries(context);
        const nodeProjectionMap = this.getProjectionMap(context);
        const edgeVar = new cypher_builder_1.default.NamedVariable("edge");
        const edgesVar = new cypher_builder_1.default.NamedVariable("edges");
        const totalCount = new cypher_builder_1.default.NamedVariable("totalCount");
        const edgeProjectionMap = new cypher_builder_1.default.Map();
        edgeProjectionMap.set("node", nodeProjectionMap);
        let withWhere;
        if (filters) {
            if (authFilterSubqueries.length > 0) {
                // This is to avoid unnecessary With *
                withWhere = new cypher_builder_1.default.With("*").where(filters);
            }
            else {
                selectionClause.where(filters);
            }
        }
        const withNodeAndTotalCount = new cypher_builder_1.default.With([cypher_builder_1.default.collect(node), edgesVar]).with(edgesVar, [
            cypher_builder_1.default.size(edgesVar),
            totalCount,
        ]);
        const unwindClause = new cypher_builder_1.default.Unwind([edgesVar, node]).with(node, totalCount);
        let paginationWith;
        if (this.pagination || this.sortFields.length > 0) {
            paginationWith = new cypher_builder_1.default.With("*");
            const paginationField = this.pagination && this.pagination.getPagination();
            if (paginationField?.limit) {
                paginationWith.limit(paginationField.limit);
            }
            if (paginationField?.skip) {
                paginationWith.skip(paginationField.skip);
            }
            if (this.sortFields.length > 0) {
                const sortFields = this.getSortFields({ context, nodeVar: node, aliased: true });
                paginationWith.orderBy(...sortFields);
            }
        }
        const withProjection = new cypher_builder_1.default.With([edgeProjectionMap, edgeVar], totalCount, node).with([cypher_builder_1.default.collect(edgeVar), edgesVar], totalCount);
        let extraWithOrder;
        const returnClause = new cypher_builder_1.default.Return([
            new cypher_builder_1.default.Map({
                edges: edgesVar,
                totalCount: totalCount,
            }),
            context.returnVariable,
        ]);
        const connectionMatchAndAuthClause = cypher_builder_1.default.concat(...preSelection, selectionClause, ...authFilterSubqueries, withWhere, extraWithOrder, withNodeAndTotalCount, unwindClause);
        const clause = cypher_builder_1.default.concat(...[
            connectionMatchAndAuthClause,
            ...prePaginationSubqueries,
            paginationWith,
            ...postPaginationSubqueries,
            withProjection,
            returnClause,
        ]);
        return {
            clauses: [clause],
            projectionExpr: context.returnVariable,
        };
    }
    getPaginationSubquery(context, edgesVar, paginationField) {
        const edgeVar = new cypher_builder_1.default.NamedVariable("edge");
        const subquery = new cypher_builder_1.default.Unwind([edgesVar, edgeVar]).with(edgeVar);
        if (this.sortFields.length > 0) {
            const sortFields = this.getSortFields({ context, nodeVar: edgeVar.property("node"), edgeVar });
            subquery.orderBy(...sortFields);
        }
        if (paginationField && paginationField.skip) {
            subquery.skip(paginationField.skip);
        }
        if (paginationField && paginationField.limit) {
            subquery.limit(paginationField.limit);
        }
        const returnVar = new cypher_builder_1.default.Variable();
        subquery.return([cypher_builder_1.default.collect(edgeVar), returnVar]);
        return new cypher_builder_1.default.Call(subquery).innerWith(edgesVar).with([returnVar, edgesVar]);
    }
    getSortFields({ context, nodeVar, edgeVar, aliased = false, }) {
        return this.sortFields.flatMap(({ node, edge }) => {
            const nodeFields = node.flatMap((s) => s.getSortFields(context, nodeVar, aliased));
            if (edgeVar) {
                const edgeFields = edge.flatMap((s) => s.getSortFields(context, edgeVar, aliased));
                return [...nodeFields, ...edgeFields];
            }
            return nodeFields;
        });
    }
    getPreAndPostSubqueries(context) {
        if (!(0, context_has_target_1.hasTarget)(context))
            throw new Error("No parent node found!");
        const sortNodeFields = this.sortFields.flatMap((sf) => sf.node);
        const cypherSortFieldsFlagMap = sortNodeFields.reduce((sortFieldsFlagMap, sortField) => {
            if (sortField instanceof CypherPropertySort_1.CypherPropertySort) {
                sortFieldsFlagMap[sortField.getFieldName()] = true;
            }
            return sortFieldsFlagMap;
        }, {});
        const preAndPostFields = this.nodeFields.reduce((acc, nodeField) => {
            if (nodeField instanceof CypherAttributeField_1.CypherAttributeField && cypherSortFieldsFlagMap[nodeField.getFieldName()]) {
                acc.Pre.push(nodeField);
            }
            else {
                acc.Post.push(nodeField);
            }
            return acc;
        }, { Pre: [], Post: [] });
        const preNodeSubqueries = (0, wrap_subquery_in_calls_1.wrapSubqueriesInCypherCalls)(context, preAndPostFields.Pre, [context.target]);
        const postNodeSubqueries = (0, wrap_subquery_in_calls_1.wrapSubqueriesInCypherCalls)(context, preAndPostFields.Post, [context.target]);
        const sortSubqueries = (0, wrap_subquery_in_calls_1.wrapSubqueriesInCypherCalls)(context, sortNodeFields, [context.target]);
        return {
            prePaginationSubqueries: [...sortSubqueries, ...preNodeSubqueries],
            postPaginationSubqueries: postNodeSubqueries,
        };
    }
    getProjectionMap(context) {
        if (!(0, context_has_target_1.hasTarget)(context))
            throw new Error("No parent node found!");
        const projectionFields = this.nodeFields.map((f) => f.getProjectionField(context.target));
        const sortProjectionFields = this.sortFields.flatMap((f) => f.node.map((sortNode) => sortNode.getProjectionField(context)));
        const uniqueProjectionFields = Array.from(new Set([...projectionFields, ...sortProjectionFields])); // TODO remove duplicates with alias
        const stringFields = [];
        let otherFields = {};
        for (const field of uniqueProjectionFields) {
            if (typeof field === "string")
                stringFields.push(field);
            else {
                otherFields = { ...otherFields, ...field };
            }
        }
        return new cypher_builder_1.default.MapProjection(context.target, stringFields, otherFields);
    }
}
exports.ConnectionReadOperation = ConnectionReadOperation;
//# sourceMappingURL=ConnectionReadOperation.js.map